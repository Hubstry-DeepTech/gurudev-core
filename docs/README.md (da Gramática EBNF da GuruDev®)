Aqui est√° o README t√©cnico da gram√°tica GuruDev¬Æ pronto para colar no GitHub, com todos os blocos de c√≥digo e espa√ßamentos corretos para renderiza√ß√£o perfeita em Markdown.  
**Basta copiar e colar o texto abaixo no seu arquivo README.md da gram√°tica:**

---

# GuruDev¬Æ EBNF ‚Äî Gram√°tica Formal da Linguagem

Esta √© a gram√°tica EBNF oficial da linguagem de programa√ß√£o GuruDev¬Æ, alinhada ao lexer implementado em Python (PLY). Ela define de forma precisa e formal a estrutura sint√°tica da linguagem, servindo como refer√™ncia para o desenvolvimento do parser, documenta√ß√£o, testes e futuras expans√µes.

---

## üìö Vis√£o Geral

- **Vers√£o:** 1.0.0-alpha  
- **Autor:** Guilherme Gon√ßalves Machado  
- **Descri√ß√£o:** Esta gram√°tica cobre todos os requisitos do whitepaper GuruDev¬Æ, incluindo blocos tr√≠plices, casos gramaticais, tipos nativos, interoperabilidade multil√≠ngue, anota√ß√µes sem√¢nticas e controle de fluxo.

---

## üå± Estrutura Principal

### Bloco GuruDev¬Æ

Cada bloco √© composto por:

- `[sobrescrita]` ‚Äî Metadados/contexto sem√¢ntico  
- `¬°codigo!` ‚Äî C√≥digo GuruDev¬Æ principal  
- `[subescritas]` ‚Äî Blocos de c√≥digo estrangeiro (interoperabilidade)  

**Exemplo:**

```gurudev
[bloco]
    [sobrescrita]
        "Contexto: autentica√ß√£o"
        [nivel="holistico"]
        [raiz="SEG"]
        [ont="acao"]
    [/sobrescrita]

    ¬°codigo!
        NOM funcao verificarSenha(String senhaInserida, String senhaHashArmazenada) {
            return hash(senhaInserida) == hash(senhaHashArmazenada);
        }
    !/codigo!

    [subescritas]
        ¬øpython?
        def verificar_senha(senha_inserida, senha_armazenada):
            return hash(senha_inserida) == hash(senha_armazenada)
        ?/python?
    [/subescritas]
[/bloco]
```

---

## üè∑Ô∏è Terminais (Tokens Reconhecidos pelo Lexer)

<details>
<summary><strong>Clique para expandir</strong></summary>

```ebnf
BLOCO_START = "[bloco]" ;
BLOCO_END = "[/bloco]" ;
SOBRESCRITA_START = "[sobrescrita]" ;
SOBRESCRITA_END = "[/sobrescrita]" ;
SUBESCRITAS_START = "[subescritas]" ;
SUBESCRITAS_END = "[/subescritas]" ;
CODIGO_START = "¬°codigo!" ;
CODIGO_END = "!/codigo!" ;

PYTHON_START = "¬øpython?" ;
PYTHON_END = "?/python?" ;
RUST_START = "¬ørust?" ;
RUST_END = "?/rust?" ;
JAVASCRIPT_START = "¬øjavascript?" ;
JAVASCRIPT_END = "?/javascript?" ;
CSHARP_START = "¬øcsharp?" ;
CSHARP_END = "?/csharp?" ;
WASM_START = "¬øwasm?" ;
WASM_END = "?/wasm?" ;
CPP_START = "¬øc++?" ;
CPP_END = "?/c++?" ;
JAVA_START = "¬øjava?" ;
JAVA_END = "?/java?" ;
SQL_START = "¬øsql?" ;
SQL_END = "?/sql?" ;
R_START = "¬ør?" ;
R_END = "?/r?" ;

NIVEL_ATTR = "[nivel=" STRING_LITERAL "]" ;
RAIZ_ATTR = "[raiz=" STRING_LITERAL "]" ;
CLAVE_ATTR = "[clave=" STRING_LITERAL "]" ;
ONT_ATTR = "[ont=" STRING_LITERAL "]" ;

STRING_LITERAL = '"' ( ANY_CHARACTER_EXCEPT_DOUBLE_QUOTE | '\\' ANY_CHARACTER )* '"' ;
INT_LITERAL = DIGIT+ ;
FLOAT_LITERAL = DIGIT+ "." DIGIT+ [ "f" ] ;
BOOLEAN_LITERAL = "true" | "false" | "verdadeiro" | "falso" ;

VOC = "VOC" ; NOM = "NOM" ; ACU = "ACU" ; DAT = "DAT" ;
GEN = "GEN" ; INS = "INS" ; LOC = "LOC" ; ABL = "ABL" ;
FUNCAO = "funcao" ; CLASSE = "classe" ; EXTENDS = "extends" ; IMPLEMENTS = "implements" ;
BOOL_TYPE = "Bool" ; STRING_TYPE = "String" ; INT_TYPE = "Int" ; FLOAT_TYPE = "Float" ;
VOID_TYPE = "Void" ; ARRAY_TYPE = "Array" ; OBJECT_TYPE = "Object" ; FORMULA_TYPE = "Formula" ;
TEMPORAL_TYPE = "Temporal" ; IMAGEM_TYPE = "Imagem" ; AUDIO_TYPE = "Audio" ;
VIDEO_TYPE = "Video" ; TABELA_TYPE = "Tabela" ; GRAFO_TYPE = "Grafo" ;
IF_KEYWORD = "if" | "se" ; ELSE_KEYWORD = "else" | "senao" ;
FOR_KEYWORD = "for" | "para" ; WHILE_KEYWORD = "while" | "enquanto" ;
RETURN_KEYWORD = "return" | "retorna" ; BREAK_KEYWORD = "break" | "quebra" ;
CONTINUE_KEYWORD = "continue" | "continua" ;
SERIE_KEYWORD = "serie" ; PARALELO_KEYWORD = "paralelo" ; EM_KEYWORD = "em" ;
PUBLICO = "publico" ; PRIVADO = "privado" ; PROTEGIDO = "protegido" ;

ASSIGN = "=" ; EQUALS = "==" ; NOT_EQUALS = "!=" ;
LESS_THAN = "<" ; GREATER_THAN = ">" ; LESS_EQUAL = "<=" ; GREATER_EQUAL = ">=" ;
PLUS = "+" ; MINUS = "-" ; MULTIPLY = "*" ; DIVIDE = "/" ; MODULO = "%" ;
AND = "&&" ; OR = "||" ; NOT = "!" ; ARROW = "->" ;

LPAREN = "(" ; RPAREN = ")" ; LBRACE = "{" ; RBRACE = "}" ;
LBRACKET = "[" ; RBRACKET = "]" ; SEMICOLON = ";" ; COMMA = "," ;
DOT = "." ; COLON = ":" ;

ID = LETTER (LETTER | DIGIT | "_")* ;

WHITESPACE = ( ' ' | '\t' )+ ;
NEWLINE = ( '\n' | '\r\n' )+ ;
COMMENT = ( "//" (ANY_CHARACTER_EXCEPT_NEWLINE)* ) | ( "/*" (ANY_CHARACTER)* "*/" ) ;

LETTER = 'a'...'z' | 'A'...'Z' | '√Ä'...'√ø' ;
DIGIT = '0'...'9' ;
ANY_CHARACTER = (* Qualquer caractere Unicode. *) ;
ANY_CHARACTER_EXCEPT_DOUBLE_QUOTE = (* Qualquer caractere Unicode exceto aspas duplas. *) ;
ANY_CHARACTER_EXCEPT_NEWLINE = (* Qualquer caractere Unicode exceto quebra de linha. *) ;
```
</details>

---

## üõ†Ô∏è Como Usar

- O lexer reconhece todos os tokens definidos nesta EBNF, incluindo `FOREIGN_CODE_CONTENT` para blocos de c√≥digo estrangeiro.
- Use esta EBNF como base para implementar o parser (ex: com PLY/Yacc, ANTLR, etc.).
- A gram√°tica est√° pronta para expans√£o futura (ex: controle de erros, multimodalidade, macros).

---

## üìù Notas T√©cnicas

- **WHITESPACE** e **NEWLINE** s√£o tokens produzidos pelo lexer, mas geralmente ignorados pelo parser, exceto onde explicitamente referenciados.
- **Coment√°rios** s√£o ignorados pelo lexer e n√£o chegam ao parser.
- **A gram√°tica √© auto-contida:** Todos os terminais est√£o definidos ao final do arquivo.
- **Consist√™ncia:** Os nomes dos tokens na EBNF batem exatamente com os nomes do Enum do lexer.

---

## üöÄ Contribuindo

- Sugest√µes, corre√ß√µes e expans√µes s√£o bem-vindas!
- Para contribuir, abra um Pull Request ou Issue neste reposit√≥rio.

---

## üìÑ Licen√ßa

[Defina a licen√ßa do projeto aqui ‚Äî ex: Apache 2.0, MIT, etc.]

---

**GuruDev¬Æ ‚Äî C√≥digo que transcende paradigmas, sintaxe que honra a tradi√ß√£o.**

---

Se precisar de mais exemplos ou quiser expandir, s√≥ pedir!
